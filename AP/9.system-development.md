# 9. システム開発

## 9.1 開発プロセス・手法

### 9.1.1 ソフトウェア開発モデル

#### ソフトウェアライフサイクル

- Plan (計画)
- Do (開発)
- See (運用・保守)

#### 共通フレーム

システムの構想から開発、運用、保守、廃棄までのライフサイクル全般の作業内容を規定したガイドライン

#### ソフトウェア開発モデル

要件定義、設計、プログラミング、テストなどの工程に分けられる

##### ウォーターフォールモデル

上流から下流へ、一貫性を持って進行

- 要件定義
  - 外部設計
    - 内部設計
      - プログラミング設計
        - プログラミング
          - テスト

##### プロトタイプモデル

- 早期からプロトタイプ (試供品) をユーザに評価してもらい、修正を繰り返す
- 要求しようの曖昧さがなくなる
- 時間・コストかかりがち
- cf. モックアップ (見た目のみの試供品)

##### スパイラルモデル

- システムを独立性の高いいくつかのサービスに分類し、部分ごとに開発
- 開発しながらコスト評価
- 小規模開発を先行させるなどによってコスト抑制が期待できる

##### インクリメンタルモデル (段階的モデル)

- 要求をいくつかの段階にわけて順次開発
- 例) コア → 詳細機能

##### 進化的モデル

- 開発を繰り返しながら要求自体を洗練させていく
- インクリメンタルモデルと比べて、要求の不完全性の存在を前提としている

##### アジャイル開発

- 1~2週間の短い期間 (イテレーション) ごとに一連の開発工程を繰り返す
- 問題を早期発見
- 変更に柔軟に対応可能
- ふりかえり (レトロスぺクティブ)
  - 作業を見直して自分の作業を改善

##### XP (エクストリームプログラミング)

- ペアプログラミング
- テスト駆動開発 (TDD)
  - 最初にテストを書いて最低限実装後、コードを洗練させる
- リファクタリング
  - 振る舞いを変えず内部動作を改良する
- 継続的インテグレーション (Continuous Integration)
- ソースコードの共有所有
- YAGNI (You Aren't Going to Need It)

#### その他の開発手法

- RAD (Rapid Application Development)
  - 2~3か月の短期間で少人数のチーム
  - [CASE ツール](TODO)
  - ライフサイクルの無限ループを避けるため、タイムボックス (一定の開発期間) を設定
- ユースケース駆動開発
  - ユーザの要求がプログラムに反映されているかを目標とする
  - 要件定義、予備設計、詳細設計、実装、設計駆動テストの流れ
- ラウンドトリップ
  - オブジェクト指向開発において、分析・設計・開発を行き来する
- クリーンルームモデル
  - 設計段階から正当性の検証を重視
  - [形式手法](TODO)
- マッシュアップ
  - 複数の提供元の API を組み合わせて新しいサービスをつくる

### 9.1.2 組み込みソフトウェア開発

#### プラットフォーム開発

- 複数機器の共通部を最初に設計・開発
- 共通部を土台として、機器ごとの機能を開発

##### MDA (モデル駆動型開発)

システムをプラットフォーム依存 / 非依存に分けてモデル化する技法

#### コンカレントエンジニアリング (コンカレント開発)

製品開発のライフサイクルを順次実施せず、同時に実施可能なところは並行して進める

- コデザイン
  - 早期にハード / ソフトを同時に設計
- コベリフィケーション
  - ハード / ソフトのいずれかが未完でもエミュレータなどで検証を行う

### 9.1.3 ソフトウェアの再利用

#### リエンジニアリング

既存のソフトウェアから新しいソフトウェアを作成する

##### リバースエンジニアリング

既存のソース → プログラム仕様 → 設計

##### フォワードエンジニアリング

設計 → プログラム仕様  → 新規のソース

#### ドメインエンジニアリング

特定領域のシステムに対して整理し、再利用を促進することで開発効率向上を図る

#### 部品による再利用

- 一度作っておけば利用するのは楽
- オブジェクト指向開発はこの点から再利用容易

#### 共通フレームの開発プロセス

- 共通フレーム (JIS X 0160)
  - システムの構想から開発、運用、保守、廃棄までのライフサイクル全般の作業内容を規定したガイドライン
  - V字モデル
    - 設計とテストを対応させたもの

##### 流れ

要件定義 → 設計 (方式 / 詳細) → 構築の順になってる

- システム開発プロセス
  - システム要件定義 - システムテスト (システム適正確認テスト)
    - 機能要件・非機能要件
  - システム方式設計 - システム結合テスト
    - システム要件をハードウェア、ソフトウェア、手作業に振り分け、実現するために必要な**システム要素**を決定
- ソフトウェア実装プロセス
  - ソフトウェア要件定義 - ソフトウェア適正確認テスト
    - 各ソフトウェア品目の要件
  - ソフトウェア方式設計 - ソフトウェア適合テスト
    - ソフトウェア品目の実現のためのソフトウェアコンポネントの設計
  - ソフトウェア詳細設計 - ソフトウェア単体テスト
    - モジュールレベルの設計
  - ソフトウェア構築
    - コーディング、コンパイル、テスト

### 9.1.5 ソフトウェアプロセスの評価

- CMMI (Capability Maturity Model Integration / 能力成熟度モデル統合)
- SPA (Software Process Assessment)

| レベル             | 説明 |
| ------------------ | ---- |
| 初期               |      |
| 管理された         |      |
| 定義された         |      |
| 定量的に管理された |      |
| 最適化している     |      |

## 9.2 分析・設計手法

## 9.3 オブジェクト指向設計

- データ中心のアプローチ
- もの同士の関係をソフトウェアで表現

### 9.3.1 オブジェクト指向の基本概念

#### オブジェクトとカプセル化

- カプセル化
  - 詳細な実装をオブジェクト内部に隠ぺい
  - 独立性が高まり、再利用しやすくなる
- オブジェクト間は**メッセージ**でやりとりし、作業を依頼しあう

#### クラスとインスタンス

- クラス
  - オブジェクトに共通する性質を抽象化して定義したもの
  - クラスの集合をクラスライブラリという
- インスタンス
  - クラスを具体的な値を持ったオブジェクトにしたもの

#### インヘリタンス (継承)

- クラスをさらに抽象化して階層関係をつくること
- 下位クラスでは上位クラスとの差分の未定義
  - **差分プログラミング**
- 基底クラス → 派生クラス

### 9.3.2 クラス間の関係

#### is-a 関係 (汎化-特価関係)

- 汎化: 下位から上位
- 特化: 上位から下位
- 例) 動物 → 犬

#### part-of 関係 (集約-分解関係)

- 集約: 下位から上位
- 分解: 上位から下位
- 例) 車 → タイヤ

### 9.3.3 オブジェクト指向の応用概念

#### ポリモーフィズム (多相性 / 多様性)

- 同じメッセージに対して異なる動作をする特性
- 例) 動く → 車が走る、飛行機が飛ぶ

#### 抽象メソッドと抽象クラス

メソッドの名前のみ定義し、実装はサブクラスで行う (オーバーライド)

- オーバーライド (再定義)
- cf. オーバーロード (上書き)

#### UML (Unified Modeling Language)

オブジェクト指向設計で用いられるモデリング言語

- 関連
- 汎化
  - 1種
  - 継承している
- 集約
  - 部品
- コンポジション
  - 集約より強い
  - 切り離せない
- 依存

#### シーケンス図

- オブジェクト間の相互作用を時間軸に沿って表す
- 実線の矢印は時間、破線の矢印はデータの流れ

##### ライフライン

オブジェクトの生存期間

##### アクティベーション (活性区間)

オブジェクトが実際に動作している区間

#### その他の図

- ユースケース図
  - 機能と利用者の相互作用を表す
  - アクタ (人、ハードウェア、外部機器など)
  - ユースケース (アクタとシステムの対話をモデル化したもの)
- ステートマシン図
  - オブジェクトの状態遷移図
- アクティビティ図
  - システムやユースケースの流れを表す
  - フローチャートの UML 版
- コミュニケーション図
  - オブジェクト間のデータの関連を重視した図

## 9.4 モジュール設計

### 9.4.1 モジュール分割技法

- データの流れに着目
  - STS 分割 (Source-Transfer-Sink)
  - TR 分割 (トランザクション分割)
  - 共通機能分割
- データ構造に着目
  - ジャクソン法
  - ワーニエ法

#### STS分割 (Source-Transfer-Sink)

- 入力 (Source)
  - 最大抽出入力点 (もはや入力といえない点まで抽象化)
- 処理 (Transfer)
  - 最大抽出出力点 (もはや出力といえない点まで抽象化)
- 出力 (Sink)

に着目して分割

#### TR 分割 (トランザクション分割)

入力トランザクションの種類によって分割

- トランザクションを入力するモジュール
- トランザクションを属性ごとに振り分けるモジュール
- トランザクションごとの処理モジュール

#### 共通機能分割

STS 分割、TR分割などで分割したモジュール内の共通部分を独立

#### ジャクソン法 (Jackson Structured Programming / JSP)

- データ構造をもとに分割する構造化設計技法
- 基本、連続、繰り返し、選択の4要素を組み合わせた木構造 (**JSP木**) で表現
- **出力**データ構造を基本計とする

#### ワーニエ法

- 集合論に基づく構造化設計技法
- **入力**データ構造をもとに「いつ、どこで、何回」という考え方で分割

### 9.4.2 モジュール分割の評価

#### 構造上の評価

##### 大きさ

モジュールが小さすぎても管理が煩雑になる

##### モジュール間インターフェース

階層構造にする場合、モジュール間のインターフェースは必要最小限にし、結合度を弱くするのが望ましい

#### 独立性の評価

- 関連しあうモジュールが相手の影響を受けにくい特性
- 保守性が高まる
- 開発段階でも並行作業が容易

##### モジュール結合度

モジュール**間**の関連性の強さ
デ・ス・セ・外・共・内

(独立性低い、結合度強い)

- 内部結合
  - 他の構造体・オブジェクト参照
- 共通結合
  - グローバルなデータ参照
- 外部結合
  - 他のモジュールが参照可能な外部のデータを参照
- 制御結合
  - 処理が引数に依存
  - cf. [論理的強度](TODO)
- スタンプ結合
  - 構造体・オブジェクトを引数で受ける
- データ結合
  - データを引数で受ける

(独立性高い、結合度弱い)

##### モジュール強度 (結束性)

モジュール**内**の構成要素間の関連性の強さ
キ・ジョ・レン・テ・ジ・ロ・アン

(独立性低い、強度弱い)

- 暗合的強度
  - ただただ分割しただけのモジュール
- 論理的強度
  - 引数で選択される機能が決まるモジュール
  - cf. [制御結合](TODO)
- 時間的強度
  - 同じタイミングで実行されるかでまとめたモジュール
- 手順的強度
  - 複数の逐次的に実行する処理をまとめたモジュール
  - 順番固定
- 連絡的強度
  - 手順的強度 + モジュール内の機能間に関連
- 情報的強度
  - 同じデータにアクセスするモジュール
- 機能的強度
  - 1つの機能から成るモジュール

(独立性高い、強度強い)

#### 領域評価

モジュールの制御・影響領域を評価する

- 制御領域
  - 自分、下位モジュール
- 影響領域
  - モジュール内の決定が影響を及ぼすモジュール

#### コード設計

- 順番コード
  - 発生順に番号をつける
  - けた数少ない
- 区分コード
  - グループで分割し、グループ内で連番
  - 少ないけた数でグループ化可能
- けた別コード
  - データを大・中・小と階層化して、層内で連番
  - 分類基準が明確
  - けた数大きくなりやすい
- 表意コード (ニモニックコード)
  - 商品の略称や記号をコード化
  - 覚えやすいが分類には不便

制御領域 > 影響領域となっていれば独立性高い

## 9.5 テスト

- テスト
  - ブラックボックステスト
    - 同値分割
      - 有効同値クラス
      - 無効同値クラス
    - 限界値分析
    - 原因結果グラフ
    - 実験計画法
  - ホワイトボックステスト
    - 命令網羅
    - 判定条件網羅 (分岐網羅)
    - 条件網羅
    - 判定条件 / 条件網羅
    - 複数条件網羅

### 9.5.1 ブラックボックステスト

プログラムの外部仕様に基づくテストデータを用意して、入力に対して正しい出力が得られるか

#### 同値分割

同じグループ内の任意の代表値をテストデータとする

#### 限界値分割

それぞれのグループの境界値をテストデータとする

#### 原因結果グラフ

- 入力 (原因)、出力 (結果) の論理結果をグラフ化
- 同値、否定、和  (OR)、積 (AND)

#### 実験計画法

- テストケース膨大な時有効
- **直行表**用いる
- それぞれのグループのテストケースの直行をとる

### 9.5.2 ホワイトボックステスト

プログラム内部論理の正当性の検証を行う
メ・ハ・ジョ・ハジョ・フ

#### 網羅性

- 命令網羅
  - すべての命令を少なくとも1回テスト
- 判定条件網羅 (分岐網羅)
  - 全体の判定条件に対して真偽の場合をテスト
  - 真・偽と偽・偽
- 条件網羅
  - 判定条件内の複数の条件の真偽の場合をテスト
  - 真・偽と偽・真
- 判定条件 / 条件網羅
  - 判定条件網羅 + 条件網羅
- 複数条件網羅
  - 判定条件を構成する各条件の組み合わせをすべてテスト

#### 制御パステスト

- 処理経路を網羅的に実行させて動作を検証するテスト
- フローグラフに置き換える
  - 逐次処理、分岐処理、繰り返し処理に分けてノードとエッジで結ぶ

#### データフローテスト

- プログラムのデータや変数の流れが正しいか検証
- 定義、使用、消滅の順に正しく処理されているか

### 9.5.3 モジュール集積テスト技法

単体テスト終了済みのモジュールを組み合わせて行う結合テストの手法

- モジュール集積テスト技法
  - 増加テスト
    - ボトムアップテスト
    - トップダウンテスト
    - 折衷テスト (ボトムアップ + トップダウン)
  - 非増加テスト

#### 増加テスト

##### ボトムアップテスト

- 下から結合していく
- 初期からテストできる
- モジュールの変更が下位に及ぶ
- 既存のシステム改修に適する

##### トップダウンテスト

- 上から結合していく
- はじめはスタブが必要で、テスト並行して開発するの困難
- 上位モジュールは何度もテストでき、信頼度高まる
- 新規システム開発に適する

### その他のテスト

- システムテスト
  - 機能テスト
  - 性能テスト
  - 操作性テスト
  - 障害回復テスト
  - 負荷テスト
  - 耐久テスト
  - 例外テスト
- リグレッションテスト (回帰テスト)

## 9.6 テスト管理手法

### 9.6.1 バグ管理図

#### 信頼度曲線 (バグ曲線)

横軸に時間、縦軸にバグ累積個数

- 開始直後は少ない
- 時間経過とともに増加
- 最終的にある一定値に収束

#### バグ管理

- 信頼曲線の増え方が急
  - プログラムの質が悪い
- 信頼曲線の増え方が緩い
  - テストの質が悪い

### 9.6.2  バグ数の推定方法

#### バグ埋め込み法

- $ \frac{発見された埋め込みバグ}{埋め込みバグ} = \frac{発見された潜在バグ}{潜在バグ} $

#### 2段階エディット法

- A, B は独立したテストグループ
- $ N = \frac{(N_A \times N_B)}{N_{AB}} $
  - それぞれエラー検出数を総エラー数の確率としてとらえる
  - 独立事象の乗法定理が適用できる

## 9.7 レビュー

### 9.7.1 レビューの種類と代表的なレビュー手法

#### レビュー

成果物の妥当性を検証

- 承認レビュー
- 成果物レビュー

##### 種類

- 机上チェック (1人)
- ピアレビュー
- IV&V (Independent Verification and Validation)
  - 独立した機関が行う

#### 代表的なレビュー手法

##### ウォークスルー

- 作成者が説明者となり行われる
- 参加者は対象物を検証し、不明点・問題点を指摘
- 参加者はお互い対等
- エラー修正は作成者
- 修正作業は検討テーマにならない

##### インスペクション

作成者以外の参加者がモデレータとして進行するレビュー

##### ラウンドロビンのレビュー

レビュー参加者が持ち回りでレビュー責任者を務める

##### パスアラウンド

成果物を複数人ノレビューアに個別に検証してもらう

#### デザインレビュー

設計のレビュー (成果物が設計仕様書)

##### 外部設計書

- 要求されたシステム要件が定義されているか
- 実現可能性・妥当性

##### 内部設計書

- 外部設計との整合性
- モジュール間のインターフェースの正当性
- 標準に準拠

#### 形式手法

論理学や離散数学を基礎とした形式的な仕様・モデル検証によって品質を確保

##### モデル規範型形式仕様記述言語

- VDM-SL
- VDM++
