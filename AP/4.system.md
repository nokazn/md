# システム構成要素

## システムの処理携帯

- 集中処理
- 分散処理

### 集中処理システム

- 1台のホストマシンで複数の業務を行う
- 処理方式はオンライントランザクション
- 特に、最低限の機能のみをもった端末で操作するものをシンクライアント

#### Pros

- システム全体の資源管理、セキュリティ確保が容易
- 運用・保守要員の組織化、集中化による人件費の削減
- 障害発生時の原因究明の容易さ
- データの一貫性を担保しやすい

#### Cons

- 一部がダウンするとシステム全体が落ち、一部の故障が全体に及ぼす影響が甚大
- 昨日の追加・変更が行いにくく、バックログの堆積が発生しやすい

### 分散処理

- データ・昨日を各マシンに分散させ、ネットワークを通じてリソースを共有
- 局所的な処理は分散コンピューターシステムで、システム横断的な処理は集中処理方式となるともいえる
- [クライアントサーバーシステム](TODO) など

#### Pros

- 障害発生時の影響を局所化でき、全体におよぼす影響は小さい
- 局所的な機能の追加・変更がしやすい
- 複数のマシンの特性に合わせて効率的に処理を行わせることができる

#### Cons

- ユーザーが個別に所有するリソースについては管理しにくい (管理者不在)
- セキュリティの確保、障害発生時の原因究明が困難
- 運用管理が複雑で、維持費がかかる

#### 形態

構成の観点からみた水平分散、垂直分散と分散対象からみた機能分散、負荷分散に分かれる

| 種類         | 説明                                                         |
| ------------ | ------------------------------------------------------------ |
| 水平機能分散 | 業務の種類、維持管理の責任によって分ける                     |
| 水平負荷分散 | 同じアプリケーションを複数のマシンで実行可能にする ([可用性](TODO)の向上) |
| 垂直機能分散 | 一連の処理機能を階層的に分け、階層ごとにマシンを分ける       |

※ 垂直負荷分散は存在しない

### ハイパフォーマンスコンピューティング (HPC)

複数のマシンを LAN で接続し、CPU等の資源を共有して単一の高性能なコンピューターとして利用できるようにする

- グリッドコンピューティング
- クラスタリング

#### グリッドコンピューティング

- ネットワーク上にある仕様の異なる複数のコンピューターを統一的に扱う
- 中央ぼサーバーで処理を分割し、他の複数のコンピュータで並列処理を行う

#### クラスタリング

- 複数のコンピューターを相互に接続し、高い可用性・処理能力を持ったシステムを構築する

##### クラスタシステム

- 例えば、磁気ディスク装置を共有し、複数のコンピュータがそれを参照して処理を行う
- [NFS](TODO) では性能上の問題があるので、DAFS (Direct Access File System) が使用される

##### ロードバランシングクラスタ

特定のコンピューターに処理が集中しないように分散させる (HPC というより負荷分散)

##### ハイパフォーマンスクラスタ

膨大な1つの処理を複数のコンピューターに分割して並列処理する (HPC)

### 負荷分散技術

#### RPC (Remote Procedure Call)

- 他のマシンの手続きを同一マシン上の手続きであるかのように呼び出せる機能
- 呼び出す/呼び出されるプロセスは互いに独立していて、異なる OS 間でも呼び出せる
- [CORBA](TODO), gRPC など

#### NFS (Network File System)

- UNIX系のマシンで、ネットワークを通じてファイルを共有する仕組み
- RPC上で実現される

#### Hadoop

- 大規模データを並列分散処理で格納・処理するオープンソースのミドルウェア
- $ 2^{50} \simeq 10^{15} $ 級のデータを扱える
- HDFS (Hadoop Distributed File System) と MapReduce で構成される

##### HDFS (Hadoop Distributed File System)

- 複数ノードのローカルファイルシステムを結合し、1つの共有ファイルシステムを作成し高スループットの読み込みを実現
- データブロックを複製し、複数のデータノードに格納することで信頼性を確保

##### MapReduce

大量データを複数のサーバーで並列処理可能にするしくみ

## クライアントサーバーシステム

- サービスを要求する側と提供する側に分割
- 垂直機能分散の代表的な例
- サーバーの機能を専用化することで個々の性能を向上させることができる
- UNIX の X Window システムがはじまり

### 2層クライアントサーバーアーキテクチャ

- クライアントにロジックと UI が混在し、肥大化、アプリケーション間での相互矛盾が発生しやすい
- ロジック修正時にはクライアントのプログラムをすべて書き換える必要がある

### 3層クライアントサーバーアーキテクチャ

- プレゼンテーション層、ファンクション (アプリケーション層)、データベースアクセス層に分ける
- クライアントから業務ロジック部分を分割

#### Web-DB 連携システム

- クライアントのアプリケーションソフトを Web ブラウザとし、Web サーバー、アプリケーションサーバー (AP サーバー)、DB サーバーの3層構造から成る
- クライアント側の環境を統一する必要がなく、ブラウザさえあればサービスを利用でき、コストの削減も期待できる

### ストアドプロシージャ

- SQL の実行可能なプログラムを予めデータベース内に格納しておき、クライントから Call 文で呼び出す
- 2層クライナトサーバー構成といえる

#### Pros

- クライアントから１つずつ SQL 文を送信する必要がなく、通信量が削減できる
- データベースアクセスの手続きを共通化できる
- 機密性の高い処理をプロシージャー化することでセキュリティの向上が期待できる

### MVC モデル

- 機能と UI の相互依存を弱めることによって修正や再利用性の向上を目的としたアーキテクチャパターン

#### 構成

- Model 層 - ビジネスロジック
- View 層 - 入出力
- Controller 層 - Model 層と View 層の制御

## 4.3 システムの構成方式

### 4.3.1 デュアルシステム

- 1つの処理を同時に行う2組のコンピューターから成る
- 処理結果を一定時間ごとに照会 (クロスチェック) し、不整合が発生したらやり直す
- 障害発生時は切り離してもう一方で続行する

#### Pros (vs デュプレックスシステム)

- MTTR (平均修理時間) は障害発生時の切り離し時間のみで、短い

#### Cons (vs デュプレックスシステム)

- 結果を照合する分スループットは落ちる
- 高価

### 4.3.2 デュプレックスシステム (待機冗長方式)

- 主系 (運用系) でオンライン処理を行い、待機系でバッチ処理やシステム開発を行う
- 主系に障害が発生した場合は待機系が代わって処理を行う
- ホットスタンバイ方式、ウォームスタンバイ方式、コールドスタンバイ方式などの待機の方式がある

#### Cons

- MTTR (平均修理時間) は長い

#### ホットスタンバイ方式

- 待機系を最初から起動しておき、主系に障害が発生したら自動で切り替える
- システム監視機構が設けられている

#### ウォームスタンバイ方式

- OS は起動させるが業務システムは起動させずに待機させる
- データベースの更新内容をログなどを利用して待機系に反映させておくなどして、データだけをバックアップする

#### コールドスタンバイ方式

- 通常は待機系でほかの処理を行い、障害発生時にその処理を中断してシステムを再起動し、主系のシステムを待機系で行う

### 4.3.3 災害を考慮したシステム構成

- 災害発生時を想定して、バックアップセンターが設置される
- バックアップセンターの設置方式として、ホットサイトとコールドサイトがある
- 別の地域にバックアップセンターを設置する構成を地域分散構成という

#### ホットサイト

- 災害発生時に短時間で切り替えられるようバックアップセンターを常に待機させておく
- 定期的に必要なデータを送信しておく必要がある

#### コールドサイト

- 平時は別の目的で使用し、災害発生時は機材等を搬入してバックアップセンターとして機能させる

### 4.3.4 高信頼化システム

- フォールトトレランス (耐故障)
  - フェールソフト
  - フェールオーバー
  - フェールセーフ
  - フォールトマスキング
  - フールブルーフ (誤操作対応)
- フォールトアボイダンス (故障排除)

#### フォールトトレランスの実現方法

##### フェールソフト

- 性能の低下はやむを得ないとしてもシステム全体を停止させないようにする考え方
- 機能が低下した状態で処理を続行することをフォールバック (縮退運転) という

##### フェールオーバー

- 障害発生時に自動的にほかのシステムに処理を引き継がせ、切り替え処理を利用者に意識させないようにする考え方
- 障害回復後に元のシステムに処理を戻すことをフェールバックという
- 仮想サーバー上のソフトを停止させずに別のサーバーへ処理を移動させる技術をライブマイグレーションという

##### フェールセーフ

- 障害発生時の影響を最小限にし、安全性を担保する考え方

##### フォールトマスキング

- 障害発生時の影響を外部に出ないようにする考え方
- 障害を他のシステムから隠ぺいしたり、自律回復が行えるようにする

##### フールプルーフ

- 意図しない使われ方をしても誤作動が起こらないようにする考え方

### 4.3.5 信頼性の向上や高速化の実現するストレージ技術

#### RAID (Redundant Arrays of Independent Disks)

- 複数の磁気ディスクを並列に並べてそれらを論理的な1台のディスクとして扱えるようにする

##### RAID0

- データを複数のディスク装置に分散して配置 (ストライピング) して速度向上
- 1台でも障害が発生したら稼働不可
- 全体の稼働率 $ R^2 $

##### RAID1

- 複数のディスク装置に同じデータを書き込んで (ミラーリング) 信頼性向上
- 冗長度高い
- 全体の稼働率 $ R^2 + (1-R) \times R + R \times (1-R) = 2R-R^2 $

##### RAID2

- RAID0 にエラー訂正符号 (ハミング符号 / ECC (Error Correcting Code)) 用の複数のディスクを追加し、障害発生時に復元できるようにしたもの

##### RAID3 / RAID4

- RAID0 にパリティというエラー訂正情報を保持するディスクを追加し、障害発生時に復元できるようにしたもの
- RAID3 はビット単位、RAID4 はブロック単位でストライピングを行う
- 読み込みはストライピング効果により高速だが、書き込みはパリティディスクにアクセスが集中するためあまり速くない
- 1台のディスク装置の故障まではカバーできる
- 全体の稼働率 R^2 + 3R(1-R) = 3R^2^-2R^3^

##### RAID5

- RAID4 を改良し、データとパリティを分散させることでパリティディスクへのアクセス集中による書き込み速度低下を改善する方式
- ブロック単位でストライピングを行う
- 1台のディスク装置の故障まではカバーできる

##### RAID6

- 異なる計算方式を用いた別のパリティディスクを付加する
- 2台のディスク装置の故障にも対応できるようにしたもの

##### RAID01 (RAID0+1)

- RAID0 と RAID1 を組み合わせる
- RAID0 の方式でストライピングしたディスク装置群をを RAID1 の方式でミラーリングする

#### NAS (Network Attached Storage)

- ストレージ → LAN のように接続するファイルサーバー専用機
- [NFS (Network File System)](TOOD) や CIFS (Common Internet File System) などのプロトコルに対応しているため異なるOS間でもファイルを共有できる

### SAN (Storage Area Network)

- ストレージ → サーバーのように接続するストレージ専用の高速ネットワーク
- 従来は SCSI-3 規格に対応するファイバチャネル (Fiber Channel) が用いられてきたが、現在では SCSI プロトコルを TCP/IP 上で使用する iSCSI を用いた IP-SAN も使用される
- LAN 環境と FC-SAN 環境を統合する技術として、TCP/IP を使用せず直接 FC フレームをイーサーネットで通信する FCoE (Fiber Channel over Ethernet) もある
  - TCP/IP 上で動作する iSCSI よりオーバーヘッドが小さい
  - 既存の Ethernet を利用するのではなく、拡張 Ethernet (CEE) 上で動作する

## 4.4 システムの性能

### 4.4.1 システムの性能指標

#### スループット

- 単位時間あたりに処理できる仕事量

#### レスポンスタイム (応答時間)

- 処理要求を出して利用者に応答が返ってくるまでの時間
- オンラインシステムの業務処理性能の評価指標としてトランザクション応答時間は重要

#### ターンアラウンドタイム (TAT)

- ジョブの投入から出力終了までの時間
  - CPU 時間 + 入出力時間 + 処理待ち時間
- バッチ処理の性能指標として用いられる

#### MIPS と FLOPS

- MIPS (Million Instructions per Second)
  - 1秒間に実行可能な命令数を 10^6^ 単位で表したもの
  - CPU 性能比較等に用いられる
- FLOPS (Floating-point Operations per Second)
  - 1秒間に実行可能な浮動小数点演算回数
  - 科学技術計算の演算性能の指標として用いられる (ベクトルコンピューターなど)

### 4.4.3 システムの性能評価

#### 命令ミックス

- 各命令に対して、実行速度 × 出現頻度として平均の命令実行時間を求めたもの
- コマーシャルミックス (事務計算) とギブソンミックス (科学技術計算)
- 逆数をとると MIPS となる

#### ベンチマーク

- 評価対象の業務処理の典型例をモデル化したプログラムを用いて実行時間等を計測して性能を評価する
- SPEC (Standard Performance Evaluation Corporation)、TPC (Transaction Processing Council) など

##### SPEC (Standard Performance Evaluation Corporation)

システムの構成要素の評価を行う

###### 代表的な仕様

- SPECint - 整数演算性能の評価
- SPECfp- 浮動小数点演算性能の評価

制定された年度によって SPECint95, SPECfp2000 などがある

##### TPC (Transaction Processing Council)

- システム全体の性能の評価を行う
- OLTP (オンライントランザクション処理) の性能を評価するもの

###### 代表的な仕様

- TPC-C
  - トランザクション処理、データベース処理など
  - 実際の受発注に近い環境
- TPC-E
  - TPC-C の後継 (2007年)
  - 証券会社の業務モデルを用いる
- TPC-App
  - アプリケーションサーバーと Web サーバーの評価
- TPC-H
  - 意思決定支援システムの評価

### 4.4.4 モニタリング

- 各プログラムの実行状態、リソースの利用状況を測定
- ボトルネックを見つけ、チューニングを行うのにつなげる

#### ソフトウェアモニタリング

OS 組み込みの機能を用いたり、専用のソフトウェアを用いる

##### 測定対象

- タスクごとの CPU 使用時間
- タスクごとの入出力回数
- 仮想記憶システムのページング回数
- スーパーバイザーモードで動作する時間の割合
- メモリの使用状況
- 応答時間

##### Pros

- 測定項目の変更・追加が容易

##### Cons

- 測定誤差が生じやすい

#### ハードウェアモニタリング

ソフトウェアモニタリングでは測定できない項目を測定する

##### 測定対象

- キャッシュメモリのヒット率
- 実行命令回数と所要時間
- 命令種別の使用回数
- 主記憶アドレスごとのアクセス頻度
- チャネルの利用率

##### Pros

- 測定誤差が生じにくい

##### Cons

- 測定項目の変更・追加が困難

## 4.5 システム性能設計

### 4.5.1 キャパシティランニング

**将来**予測される負荷を考慮し、性能要件を満たすシステム構成を検討すること

#### 検討項目

- CPU 性能
- メモリの大きさ
- メモリのアクセス時間
- チャネルの種類と転送速度
- 入出力データ転送時間
- 通信速度

### 4.5.2 キャパシティ管理

- システムの負荷の現状の分析、将来の予測を行い、リソースを管理・調整すること
- 定期的にリソースの利用状況や性能を測定し、ボトルネックとなっている・なりそうな箇所を特定

### その他の性能評価技法

- カーネルプログラム法
  - 行列計算などの実行結果で評価
- カタログ性能
  - 各構成要素のカタログ性能データを収集して評価
- シミュレーション
  - システムを模倣したモデルを仮想的に実現し、評価

## 4.6 待ち行列理論

TODO

## 4.7 システムの信頼性

- 信頼性
  - どのくらい安定して稼働するか

### RASIS

- Reliability (信頼性)
  - 故障せずに連続的に稼働するか
  - MTBF (Mean Time Between Failure / 平均故障間隔) が指標として用いられる
- Availability (可用性)
  - システムの使用可能度
  - MTBF / (MTBF + MTTR) で求められる稼働率が指標として用いられる
  - Reliability の大きさと Serviceability の小ささに影響を受ける
- Serviceability (保守性)
  - 修理のしやすさ
  - MTTR (Mean Time Between Recovery / 平均修理時間) が指標として用いられる
- Integrity (保全性)
  - システムに記録されているデータの完全性 (不整合が発生しないか)
- Security (安全性 / 機密性)
  - システム内のデータの災害、障害、ネット犯罪などに対する耐性

### バスタブ曲線

- ハードウェアの信頼性管理手法
- [フォールトアボイダンス (故障排除)](TODO) を評価
- 経過時間を横軸、故障率を縦軸にとる

#### ワイブル分布

$$
R_t = 1 - e^{(\frac{λ}{T})^m}
$$

##### ライフサイクル

- 初期故障期間
  - 製造不良や環境への不適合など(m < 1)
- 偶発故障期間
  - 故障率一定 (m = 1)
- 摩耗故障期間
  - 材料の劣化や摩耗による耐用寿命の終盤 (m> 1)

### 4.7.2 システムの信頼性計算

#### 稼働率 (Availability)

$$
稼働率 = \frac{稼働}{稼働 + 修理} = \frac{MTBF}{MTBF + MTBR}
$$

##### MTBF を長くする (Reliability)

- システムの冗長度を高める
- 予防保守 (定期点検など) の実行
- 自動誤り訂正機能などの導入

##### MTBR を長くする (Serviceability)

- ログをとる
- 遠隔地保守
- 保守センタの分散配置

##### 直列接続の稼働率

$$
稼働率 = R_1 \times R_2
$$

##### 並列接続の稼働率

$$
稼働率 = 1 - 不稼働率 = 1 - (1 - R_1) \times (1 - R_2)
$$

#### 故障率

- 単位時間あたりに故障する回数の**期待値**
- 直列に接続されたシステムの故障率は各システムの故障率の総和で求まる

$$
MTTR が MTTF に対して十分小さいとき、\\
故障率 = \frac{1}{平均故障間隔} = \frac{1}{MTBF}
$$
