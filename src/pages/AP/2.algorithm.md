# 2.アルゴリズム

## 2.1 リスト

### 2.1 リスト構造

#### 連結リスト

- 単方向リスト
- 双方向リスト
- 循環リスト

### 2.1.2 データの追加と削除

### 2.1.3 リストによる２分木

`[key, parent, left, right]`

## 2.2 スタックとキュー

### 2.2.1 スタックとキューの基本操作

#### スタック

- LIFO (Last In First Out)
- Push と Pop
- 再帰処理に用いられる (制御スタック)
- [逆ポーランド表記](TODO)

#### キュー

- FIFO (First In FIrst Out)
- Enq (エンキュー) と Deq (デキュー)

## 2.2. グラフの探索処理

- 深さ優先探索
  - スタック
  - 記憶域消費の効率がいい
  - 最短経路ではない
- 幅優先探索
  - キュー

## 2.3 木

### 2.3.1 木構造

- 要素
  - 根
  - 節
  - 葉
- 枝

- 2分木
- 多分木

### 2.3.2 完全２分木

- すべて2つの子を持つ
- 根から葉までの深さがすべて等しい
- 葉の個数 $ 2^n $
- 葉以外の節の個数 (根 + 節) $ 2^{n-1} $

### 2.3.3 2部探索木

#### 走査 (巡回法)

- 幅優先探索
- 深さ優先探索
  - 先行順
    - 節、左、右
  - 中間順
    - 左、節、右
    - 昇順
  - 後行順
    - 左、右、節

#### 探索

要素数 n に対しての計算量は $ \log_{2}n から n $

### 2.3.4 バランス木

#### AVL 木

任意の節において、左右の部分木の高さが1以下

## 2.4 探索

## 2.5 整列アルゴリズム

- 整列 (ソート)
- 安定な整列 (同じキーの順序が入れ替わらない)

### 2.5.1 基本的な整列アルゴリズム

いずれも計算量は $ \frac{n(n-1)}{2} = O(n^2) $

- バブルソート (隣接交換法)
  - 隣同士比較して交換
  - 安定
- 単純選択法 (最小値選択法)
  - 最小値を見つけて先頭から追加していく
  - 実装次第で安定
- 単純挿入法
  - 未整列の先頭を整列済みの適切な位置に挿入していく
  - 安定

### 2.5.2 整列法の考え方

#### 逐次添加法

- 少ない個数から逐次整列させていく
- バブルソート、単純選択法、単純挿入法
- $ O(n^2) $

#### 分割統治法

- 小さい問題に分割して、各問題の解を統合
- クイックソート、マージソート
- $ O(n \log_2n) $

#### データ構造の利用

- ヒープソート
- $ O(n \log_2n) $

#### クイックソート

- 中間的な基準値をもとにした分割を要素数が1になるまで再帰的に行う
- 安定ではない
- 最大値・最小値を基準値とした場合は最悪計算量になる ($ O(n^2) $)

#### マージソート

- 1になるまで分割してから比較して併合
- 安定

#### ヒープソート

- 安定ではない
- ヒープという順序木 ($ 親 \leq 子 $) を作成し、根を取り出してヒープ再構成というサイクルを繰り返す

## 2.7 プログラム言語

### 2.7.1 プログラム構造

#### 再入可能 (Re-enterable)

- 複数のタスクから同時に呼び出されても正常に動作
- 共通部 (手続き部) とデータ部で分離

#### 再帰 (Recursive)

- 自分自身を呼び出しても正常に動作
- 呼び出す前に局所変数をスタックに退避し、呼び出したプログラムから戻ったとき取り出す
- 再入可能

#### 再使用可能 (Reusable)

- 主記憶上のプログラムをそのまま再利用できる
- 変数を初期化する必要がある

#### 再配置可能 (Relocatable)

- どの主記憶上のアドレスに配置しても実行可能
